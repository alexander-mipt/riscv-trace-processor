#!/usr/bin/env python3

import yaml
import pprint
import sys
import os

comment_string = "/*\n" \
                 " * This file is autogenerated by 'cmdgen.py' script from .yaml file\n" \
                 " * Do not try to change anything in this file\n" \
                 " * If you need to change code - change script/markdown file\n" \
                 " ***********************************************************\n" \
                 " * Written by Derzhavin Andrey (derzhavin3016) && Khaydari Farid (Tako-San) && Antipov Alexander\n" \
                 " */\n\n"

includes_string = "/*\n" \
                 " * #include\n" \
                 " */\n\n"

return_type = 'void'
context_type = 'Context&'
ir_type = 'Instr&'
opcode_type = 'Opcode'
field_type = 'Field'


def parse_yaml(fin_name):
    # parsing from file function
    with open(fin_name, 'r') as fin:
        return yaml.safe_load(fin)

def instr_enum(opcodes, arguments):
    with open('enums.hpp', 'w') as fout:
        fout.write(comment_string)

        fout.write(f"enum class {opcode_type}\n{{\n")
        for opcd in opcodes:
            num = opcd['mnemonic'].upper().replace('.', '_')
            fout.write(f"    {num},\n")
        fout.write(f"    UNDEFINED\n")
        fout.write('};\n\n')
        
        fout.write(f"enum class {field_type}\n{{\n")
        for fld in arguments:
            id = fld.upper()
            fout.write(f"    {id},\n")
        fout.write(f"    UNDEFINED\n")
        fout.write('};') 

def cmds_hashtbl(commands):
    with open('cmds.hpp', 'w') as fout:
        fout.write(comment_string)
        fout.write("#pragma once\n" \
                   "#include <cstdio>\n" \
                   "#include <unordered_map>\n\n" \
                   "#include \"parse_types.hpp\"\n\n"
                   #"#include \"enums.hpp\"\n\n")
        )
        last = commands[-1]

        for cmd in commands:
            instr = cmd['mnemonic'].upper().replace('.', '_')
            fout.write(f"{return_type} do_{instr}({context_type}, {ir_type});\n")
        fout.write(f"{return_type} do_UNDEFINED({context_type}, {ir_type});\n")
        fout.write('\n\n')
        
        fout.write(f"static std::unordered_map<std::string, {opcode_type}> OpcdHash = \\\n{{\n")
        for cmd in commands:
            instr = cmd['mnemonic'].upper().replace('.', '_')
            fout.write(f"    {{\"{cmd['mnemonic']}\", {opcode_type}::{instr}}}{',' if cmd is not last else ''}\n")
        fout.write('};\n\n')

        fout.write(f"static std::unordered_map<{opcode_type}, {return_type}(*)({context_type}, {ir_type})> Cmds = \\\n{{\n")
        for cmd in commands:
            instr = cmd['mnemonic'].upper().replace('.', '_')
            fout.write(f"    {{{opcode_type}::{instr}, do_{instr}}},\n")
        fout.write(f"    {{{opcode_type}::UNDEFINED, do_UNDEFINED}},\n")
        fout.write('};')

def cmds_cpp(commands, arguments):
    with open('cmds.cpp', 'w') as fout:
        fout.write(comment_string)
        fout.write("#include <iostream>\n" \
                   "#include \"parse_types.hpp\"\n" \
                   "#include \"cmds.hpp\"\n\n")

        for cmd in commands:
            instr = cmd['mnemonic'].upper().replace('.', '_')
            fout.write(f'{return_type} do_{instr}({context_type} ctx, {ir_type} instru)\n')
            fout.write('{\n\n')

            has_dst = 0
            if cmd['fields'] and cmd['fields'][0] == 'rd':
                has_dst = 1

            src_reg_count = 0
            imm_idx = -1
            for idx, opnd in enumerate(cmd['fields']):
                #src_reg_count = 0
                if opnd in {'rs1', 'rs2', 'rs3'}:
                    src_reg_count += 1
                if opnd in {'imm', 'imm12', 'imm20', 'jimm20', 'bimm'}:
                    imm_idx = idx
            
            if imm_idx > -1:
                imm_routine = f'    imm_routine(ctx, instru, {imm_idx});\n'
                fout.write(imm_routine)
            
            if src_reg_count:
                use_routine = f'    use_routine(ctx, instru, {has_dst}, {src_reg_count});\n'
                fout.write(use_routine)

            loads = {'lb', 'lh', 'lw', 'ld'}
            if cmd['mnemonic'] in loads:
                load_routine = f'   load_routine(ctx, instru);\n'
                fout.write(load_routine)

            stores = {'sb', 'sh', 'sw', 'sd'}
            if cmd['mnemonic'] in stores:
                store_routine = f'  store_routine(ctx, instru);\n'
                fout.write(store_routine)
            
            if has_dst:
                def_routine = f'    def_routine(ctx, instru);\n'
                fout.write(def_routine)
            
            fout.write( \
                #'    //std::cerr << __func__ << " NOT IMPLEMENTED YET" << std::endl;\n'
                '}\n\n'
            )
        fout.write(f'{return_type} do_UNDEFINED({context_type} ctx, {ir_type} instru)\n')
        fout.write('{\n')
        err_routine = f'    err_routine(ctx, instru);\n'
        fout.write(err_routine)
        fout.write( \
            #'    //std::cerr << __func__ << " NOT IMPLEMENTED YET" << std::endl;\n'
            '}\n\n'
        )

def main():
    
    yaml_in = 'risc-v.yaml'  # input()
    yaml_out = 'decode.cpp'  # input()
    yaml_dict = parse_yaml(yaml_in)

    instr_enum(yaml_dict['instructions'], yaml_dict['fields'])
    cmds_hashtbl(yaml_dict['instructions'])
    cmds_cpp(yaml_dict['instructions'], yaml_dict['fields'])

if __name__ == '__main__':
    main()


